# 为什么要将数据保存为定点数？

在数字信号处理和嵌入式系统开发中，我们常常会遇到这样一个问题：如何高效地在硬件（如 FPGA、DSP 或微控制器）中存储和处理连续的浮点信号？虽然浮点数在理论上可以表示极高的精度和极大的数值范围，但在实际硬件中，浮点运算往往资源消耗大、速度慢，甚至在很多低成本或高性能场景下根本无法实现。因此，我们通常会选择将数据保存为定点数。

定点数是一种用固定数量的二进制位来表示小数和整数的方式。通过合理选择定点格式（如 Q 格式），我们可以在有限的硬件资源下实现高效、可控的数值处理。这样做不仅能提升计算速度，还能保证数据在存储和传输过程中的一致性和可预测性。

将数据保存为定点数，意味着我们把原本连续的浮点数“量化”为离散的整数值。这一过程虽然会带来一定的精度损失，但只要设计得当，完全可以满足大多数工程应用的需求。更重要的是，定点数格式便于与硬件接口对接，无论是初始化 FPGA 存储器，还是进行仿真和测试，都能直接使用这些定点数据文件。

本说明文档将帮助你理解定点数的基本原理、常见格式，以及如何将浮点信号正确地映射为定点二进制数据，并安全地导出为 FPGA 可用的文件格式。无论你是刚入门的学生，还是需要将信号样本写入硬件的工程师，都能从中获得实用的指导。

# 固定点表示与浮点数到定点的映射说明

本文件将以通俗易懂的方式，介绍如何将连续（浮点）信号映射到定点二进制表示，帮助你理解常见的 Q 格式、两补数（two's complement）编码，以及各类导出文件（如 `.hex`、`.mem`、`.bin`、`.coe`、`.mif`、`.csv`、`.txt`）中的数据含义。

**适用对象**：希望将信号样本写入 FPGA 初始化或仿真文件的工程师与学生。

---

## 1. 基本概念

在定点数表示中，所有数据都由有限的二进制位宽来存储。常见的 Q 格式（如 Qm.n）将总位宽分为整数部分和小数部分。例如，Q1.15 表示 16 位宽度，其中 1 位用于符号和整数，15 位用于小数。

- **总位宽** (`total_bits`)：用于存储数据的二进制位数（如 16 位）。
- **小数位数** (`frac_bits`)：用于表示小数的位数（如 Q1.15 的 frac_bits=15）。
- **符号位**：最高位为符号位，采用两补数编码以支持负数。

在实际量化过程中，首先需要确定缩放因子：

    scale = 2 ** frac_bits

将浮点数转换为定点整数的公式如下：

    int_value = round(float_value * scale)

为防止溢出，需要对结果进行截断或饱和处理：

    signed 范围: min_int = -2**(total_bits-1), max_int = 2**(total_bits-1)-1
    int_value = clip(int_value, min_int, max_int)

存储时，通常将带符号整数转换为无符号二进制：

    uint_value = int_value & ((1 << total_bits) - 1)  # 两补数位模式

如果需要将定点整数还原为浮点数，可按如下方式处理：

    if uint_value 的符号位为 1:
        signed = uint_value - (1 << total_bits)
    else:
        signed = uint_value
    float_recon = signed / float(scale)

举例说明：

- Q1.15（总位宽 16，小数位 15）时，scale = 32768。
- 可表示范围为 [-1.0, 0.999969482421875]，最小步长（LSB）约为 3.05e-5。
- 浮点数 0.5 映射为 int = 16384（二进制 0x4000）。
- 负数 -0.25 映射为 int = -8192，两补数表示为 0xE000。

---

## 2. 无符号（Unsigned）映射

在某些应用场景（如 ADC 输出或部分 FPGA ROM 初始化）中，数据需要以无符号形式存储。此时，通常先将信号整体平移到非负区间，再按最大值缩放到目标位宽范围：

    shifted = values - min(values)
    scale = (2**N - 1) / shifted.max()
    uint_value = round(shifted * scale)

这种方法可以保留信号的动态范围，但会丢失原点对称性。只有在明确需要无符号数据流时才建议使用。

---

## 3. 常见导出文件格式说明

在实际工程中，定点数据常常需要以不同格式导出，以便硬件或仿真工具读取。常见格式包括：

- `.hex` / `.mem`：每行一个定点字，十六进制表示，左侧补零到完整位宽。适合内存初始化或脚本读回。
- `.bin`：原始二进制文件，每个样本按字节写入，支持大端或小端字节序。
- `.coe`（Xilinx COE）：以 `memory_initialization_radix=16;` 开头，样本用逗号分隔，十六进制表示。
- `.mif`（Altera/Intel MIF）：包含 `DEPTH`、`WIDTH`、`ADDRESS_RADIX`、`DATA_RADIX`，内容区按地址写入数据。
- `.csv`：每行一个无符号十进制数，便于后续数值处理或 Excel 打开。
- `.txt`：每行一个带符号十进制数，便于人工检查或仿真脚本使用。

注意：COE、MIF、HEX 等文本导出写入的是存储格式（即两补数的无符号位模式），接收端需按位宽和编码规则正确解释。

---

## 4. 如何选择 `total_bits` 与 `frac_bits`

选择合适的定点格式，需要结合信号的实际幅值和硬件资源：

- 若信号振幅在 [-1, +1)（如标准化正弦波），推荐 Q1.(N-1) 格式，如 16 位宽度用 Q1.15。
- 若信号幅值较大（如 ±8），则需增加整数位数，例如 Q4.11（4 位整数/符号，11 位小数，总宽 16 位）。
- 增加小数位数可提升分辨率（更小的 LSB），但会减小可表示的整数范围。
- 建议先估算信号最大绝对值 M，选择 frac_bits 使 M * 2**frac_bits 不会溢出 signed 范围，或对信号做适当缩放。

举例：信号幅值 ±5，16 位 signed，frac_bits ≤ floor(log2((2**15 -1)/5)) ≈ 11，可用 Q4.11（可表示 ±15.999，LSB≈4.88e-4）。

---

## 5. 代码示例（参考 `signal_generator_gui.py`）

以下伪代码展示了定点量化和还原的基本流程：

```python
scale = 2 ** frac_bits
ints = np.round(float_vals * scale).astype(np.int64)
ints = np.clip(ints, min_int, max_int)
uints = (ints & ((1 << total_bits) - 1)).astype(np.uint64)
# 写入 hex: format with hex_digits = (total_bits+3)//4
```

还原为浮点数（用于误差分析）：

```python
mask = (1 << total_bits) - 1
half = 1 << (total_bits - 1)
signed_vals = np.array([v - (1<<total_bits) if (v & half) else v for v in uints], dtype=np.int64)
float_recon = signed_vals / float(scale)
```

上述函数在 `signal_generator_gui.py` 中分别实现为 `quantize_signed`、`quantize_unsigned` 及文件写出工具 `save_hex`、`save_bin_with_endian`。

---

## 6. 常见误区与验证建议

在定点量化和文件导出过程中，常见的错误包括：

- 忽略溢出/饱和：量化前应估算最大幅值，必要时先做幅值缩放或软饱和处理。
- 忽略字节序：`.bin` 文件在不同工具或 CPU 下解释方式不同，务必确认接收端要求的大端或小端格式。
- 误解 `.hex` 文件：`.hex` 行是原始位模式的十六进制表示，若为两补数编码，看起来像大整数，需按带符号或无符号规则解释。

建议用小脚本读回导出的文件，重构浮点值并与原始信号比较误差（如均方根误差或最大绝对误差），以验证量化和导出流程的正确性。

---

## 7. 与 `signal_generator_gui.py` 的对应关系

本说明文档中的 `total_bits` 和 `frac_bits`，与脚本中的 `Total bits` 和 `Fractional bits` 参数完全对应。
在 GUI 中选择“Unsigned”时，脚本会采用基于最小/最大值的线性缩放实现 `quantize_unsigned`，而带符号时则使用两补数编码的 `quantize_signed`。
各类导出选项（如 `.hex`、`.mem`、`.bin`、`.coe`、`.mif`、`.csv`、`.txt`）的具体写法可参考脚本中的 `save_*` 系列函数。

---


如果你希望文档中加入：
- 更详细的数值示例（如浮点到十六进制的转换过程），或
- 针对 `COE` / `MIF` 增加可选的 `RADIX`（DATA_RADIX, ADDRESS_RADIX）说明和示例，

欢迎提出需求，我可以直接生成示例并附在文档末尾，并在 `README_GUI.md` 中插入相关链接。
