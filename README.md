# FPGA_Stimulus

本工程旨在为 FPGA/数字信号处理开发者、算法工程师和硬件验证人员，提供一套高效、易用的信号生成与定点编码工具链，支持多种信号类型、定点编码方式和主流文件格式，便于与 FPGA、DSP、仿真环境等系统进行数据交互。

一个用于生成、导出、导入 FPGA/数字信号测试数据的工具集合（包含 Python GUI 与 MATLAB 脚本）。

## 工程结构与主要功能

- **信号生成与编码**：支持 Sine（正弦）、Square（方波）、PRBS（伪随机序列）等常用测试信号，参数可自定义。
- **定点编码与导出**：支持多种定点编码（Q-format、补码、无符号），可导出为 `.hex`、`.mem`、`.bin`、`.csv`、Vivado COE、MIF 等格式，适配 FPGA/数字系统。
- **数据导入与预览**：支持多种格式数据文件导入，自动识别元数据并还原信号，便于二次处理和验证。
- **元数据自动化**：导出/导入均支持自动生成和解析 JSON 元数据，确保数据无歧义流转。
- **跨平台支持**：核心工具为 MATLAB GUI，同时配套 Python 版本，满足不同开发环境需求。

## 文件结构说明

- `signal_generator_gui.m`：MATLAB 主程序，图形界面信号生成与编码工具。
- `README_GUI_ForMatlab.md`：MATLAB GUI 使用指南，详细介绍界面操作与信号生成流程。
- `README_GUI_ForPy.md`：Python 工具链使用说明，适合自动化批量处理或嵌入式开发。
- `assets/`：界面截图、示例数据等资源文件。
- 其它脚本/工具：如 Python 版本信号生成器、辅助脚本等。
- `readFromCSV.m`：MATLAB 脚本，用于从 CSV 文件导入样本并把第二列中以 3 字节 Q1.23 格式（例如带前缀 "0x" 的十六进制字符串，如 "0x005A..."）表示的值逐行转换为浮点数数组 `mic_float` 并导入到工作区。脚本会忽略第一列并把第一行视为表头；实现中会对输入进行容错（例如清除非十六进制字符、截取最低 24 位并按两补数转换），常见用法是在 MATLAB 命令窗口运行 `readFromCSV` 或在脚本头部设置文件路径后运行。
- `readFromBIN.m`：MATLAB 脚本，用于从原始二进制文件读取样本（每 3 字节为 1 个样本，采用大端字节序），将 24-bit 两补数解释为有符号值并按 Q1.23 标度转换为浮点数组 `mic_float`。使用方式同样是在 MATLAB 中运行 `readFromBIN` 并在脚本内或交互式选择要读取的文件。该脚本对文件大小、对齐和异常字节会做基本校验并在发现不一致时给出诊断信息。

## 典型应用场景

- FPGA/DSP 仿真与验证：快速生成定点测试数据，导入仿真环境或硬件平台。
- 算法开发与定点化：支持浮点到定点的量化、误差分析与可视化。
- 数据格式转换：在不同工具链、硬件平台间无缝交换信号数据。

## 快速入门

1. 推荐先阅读 [📖MATLAB GUI 使用指南](README_GUI_ForMat.md) 或 [📖Python 工具链说明](README_GUI_ForPy.md)，根据开发环境选择合适入口。
2. 按照指南配置环境，运行主程序或脚本。
3. 参考本总纲及附录，了解编码原理、元数据要求和文件格式细节。

如需了解定点编码原理、文件格式和元数据规范，请参见本文件后续附录。

## 附录：编码与文件存储格式

下面用平实易懂的语言把常用的数制（unsigned、two's complement）和定点（Q-format）编码，以及它们与 ADC/DAC 采样数位、字节存储之间的对应关系说明清楚，便于在生成/导入/导出数据时不出歧义。
在有关数字电路以及计算机的导论课程中，通常都会介绍关于数制和码制的基础知识，然而一般只涉及整数的数码表示，而没有将小数部分纳入讨论范围。本文档旨在填补这一空白，帮助读者理解在实际工程应用中如何选择和使用合适的编码方式来表示数字信号。

### (1) 基本数制与正负码制

在讨论编码之前，先把“数制”和“码制”两个概念理顺：**数制指的是我们用来书写数值的基数系统**，比如日常十进制（base-10）、二进制（base-2）、八进制（base-8）和十六进制（base-16）；在工程中二进制是底层表示，八进制和十六进制常用于以便捷地显示或书写二进制位。不同进制之间的转换有简单的方法：将十进制转换为二进制常用除2取余法（不断除以2取余数并逆序组合）；从二进制到十六进制或八进制可以直接按位分组转换，因为十六进制的每一位正好对应4个二进制位，八进制的每位对应3个二进制位，这使得二进制与十六进制/八进制之间的相互转换既快速又无损。**码制则是指如何用二进制位模式去编码有符号数或无符号数**：原码（sign-magnitude）直接用一位做符号，其余位表示大小；反码（one's complement）把负数按位取反得到；补码（two's complement）则在取反后加一，或用规则性更强的解释方式（如果最高位为1，则对应的有符号值等于无符号值减去2^N）。三者在表示上会产生不同的位图——同一组位，如果按不同码制解释，得到的数值可能完全不同，因此在文件交换和设备对接时必须明确约定所用的码制。

在工程实践中，补码被广泛采用，因为它使加减运算在逻辑上与无符号加法一致（硬件实现简单且溢出行为可控），没有“正零/负零”的二义性，并且便于使用统一的位图存储与传输。

### (2) 补码运算与溢出：规则、检测与工程处理

二补码的一个重要性质是：按位图直接做无符号加法并取低 N 位，其结果在模 2^N 意义下等同于二补码的加减法，这就是为什么硬件可以用相同的加法器同时处理有符号和无符号运算的原因。然而这种“模 2^N”的自然行为会导致结果环绕（wrap‑around），当真实数学结果超出可表示范围时就会出现溢出。

判断溢出的简单规则是基于操作数与结果的符号：对于加法，如果两个加数的符号相同而结果符号相反，则发生了有符号溢出；对于减法，可将减法视为加上被减数的相反数并用相同规则判断。用 N 位表示时，允许的范围为 [ -2^(N-1), 2^(N-1)-1 ]，任何超出这个区间的数学值在不做额外处理的情况下都会被截为低 N 位（即环绕）。

***注意硬件的“进位（carry）”位与有符号溢出不是同一概念**：进位反映的是无符号加法是否超出 2^N，而有符号溢出用上面的符号规则来判断。*

在实际工程中，最有效的溢出处理办法之一就是“增加位数”，也叫扩展位宽（widening）。比如在定点累加、乘法或滤波器状态保存时，临时变量可以用比最终输出更宽的位数（如 N+2、N+8 甚至 2N 位）来存储中间结果，这样即使多次累加或乘法后数值超出原本 N 位的范围，也不会立即发生溢出。**只有在最终输出或写入文件时，才将结果量化回目标位宽（N 位），此时可以选择饱和（saturate）或环绕（wrap）策略。**

扩展位宽不仅能显著降低溢出风险，还能提高定点算法的精度和鲁棒性，是数字信号处理和硬件设计中常用的工程手段。实际应用时，建议在所有关键路径（如累加器、乘法链路、滤波器状态）都预留足够的保护位（guard bits），并在最终输出阶段统一做舍入和饱和处理，这样既能保证动态范围，又能避免因溢出导致的系统不稳定。

### (3) 小数的浮点/定点码制

当我们把真实的模拟量或浮点数映射到位图时，常用两类思路：**无符号映射（用于非负量或 ADC 的原始码）**和**定点映射（用于在硬件上以整数运算替代浮点运算）**。

+ **无符号映射**的一个常见简化公式是将已知范围 [vmin,vmax] 线性映射到整数区间 0..2^N−1：

  ```
  U = round( (value - vmin) / (vmax - vmin) * (2^N - 1) )
  value = U / (2^N - 1) * (vmax - vmin) + vmin
  ```
+ 而**定点（Q‑format）** 通过固定小数位把实数变为整数。

  + **定点的概念与计算机数据中的浮点数密切相关。** 小学时从整数数制出发开始介绍，只需要引入小数点的概念即可将数域拓展到含小数的完整实数域。**在二进制的表示中实际上也是同理**，根据小数点所设定的位置差异，可以区分为定点和浮点码制两类。在实际工程应用中，尤其是在嵌入式系统和数字信号处理中，浮点数的硬件实现成本较高，且性能有限，因此定点数表示（fixed-point representation）成为一种常用的替代方案。**定点数通过预定义小数点位置，将实数映射为整数，从而利用整数运算单元进行高效计算。**
  + 若采用 Signed Q(N,frac)，编码通常按以下两步：
    ```
    I = round(value * 2^frac)，
    U = mod(I,2^N) ∈ [-2^(N-1), 2^(N-1)-1]
    ```
    为便于存储或与无符号接口交互，常把位图写为 U = mod(I,2^N)。
  + 反向恢复时把位图解释为有符号整数再除以 2^frac 即可得到近似的浮点值。
